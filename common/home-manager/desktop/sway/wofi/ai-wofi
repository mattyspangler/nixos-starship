#!/usr/bin/env bash
# ~/ai-wofi
# shellcheck disable=SC2181

set -Euo pipefail

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Constants
readonly SCRIPT_NAME=$(basename "$0")
readonly VERSION="0.0.1"

# Configuration
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/wofi-ai"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/wofi-ai"
LOG_FILE="$CACHE_DIR/error.log"
HISTORY_FILE="$CACHE_DIR/history.jsonl"
MODELS_CACHE="$CACHE_DIR/models.cache"
ROLES_CACHE="$CACHE_DIR/roles.cache"

# Load settings from hacky-wofi-settings file
# Check in order: script directory, config directory, home directory
for settings_file in "$SCRIPT_DIR/hacky-wofi-settings" "$CONFIG_DIR/hacky-wofi-settings" "$HOME/.hacky-wofi-settings"; do
    if [[ -f "$settings_file" ]]; then
        # shellcheck source=/dev/null
        source "$settings_file"
        break
    fi
done

# Consistent wofi styling - 800x800, 50x50 from top-left
WOFI_ARGS="${WOFI_ARGS:---width=800 --height=800 --xoffset=50 --yoffset=50 --location=top_left}"

# Default settings (can be overridden by hacky-wofi-settings)
DEFAULT_MODEL="${AI_WOFI_DEFAULT_MODEL:-Nano-GPT:TEE/qwen-2.5-7b-instruct}"
CODE_MODEL="${AI_WOFI_CODE_MODEL:-$DEFAULT_MODEL}"
CHAT_MODEL="${AI_WOFI_CHAT_MODEL:-$DEFAULT_MODEL}"
AI_TIMEOUT="${AI_WOFI_TIMEOUT:-30}"

# Cleanup trap
trap cleanup EXIT INT TERM
cleanup() {
    # Remove any temp files created by this process
    rm -f /tmp/wofi-ai-$$-*
}

# Initialize directories
init_directories() {
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
}

# Logging function with rotation and sanitization
log_error() {
    local error_msg="$1"
    local context="${2:-Unknown context}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Truncate long errors
    error_msg="${error_msg:0:500}"

    # Remove potential secrets (API keys, tokens)
    error_msg=$(echo "$error_msg" | sed -E 's/[0-9a-f]{32,}/[REDACTED_KEY]/g')

    # Rotate log if too large (1MB)
    if [[ -f "$LOG_FILE" ]] && [[ $(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0) -gt 1048576 ]]; then
        mv "$LOG_FILE" "$LOG_FILE.old"
    fi

    # Log to file
    echo "[$timestamp] [$context] $error_msg" >> "$LOG_FILE"

    # Also show in notification
    notify-send "AI Error" "$error_msg\n\nCheck log: $LOG_FILE" -u critical
}

# Save to history
save_to_history() {
    local prompt="$1"
    local response="$2"
    local model="${3:-$DEFAULT_MODEL}"

    if [[ -n "$prompt" ]] && [[ -n "$response" ]]; then
        jq -n \
            --arg p "$prompt" \
            --arg r "$response" \
            --arg m "$model" \
            --arg t "$(date -Iseconds)" \
            '{timestamp: $t, model: $m, prompt: $p, response: $r}' >> "$HISTORY_FILE"
    fi
}

# Clean old cache files
cleanup_old_files() {
    # Remove code responses older than 7 days
    find "$CACHE_DIR" -name "code_response_*.md" -mtime +7 -delete 2>/dev/null || true

    # Keep only last 1000 history entries
    if [[ -f "$HISTORY_FILE" ]] && [[ $(wc -l < "$HISTORY_FILE") -gt 1000 ]]; then
        tail -n 1000 "$HISTORY_FILE" > "$HISTORY_FILE.tmp"
        mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
    fi
}

# Safe config loading
load_config() {
    local config_file="$CONFIG_DIR/config"
    if [[ -f "$config_file" ]]; then
        # Parse config safely, only accepting known variables
        while IFS='=' read -r key value; do
            # Remove quotes
            value="${value%\"}"
            value="${value#\"}"

            case "$key" in
                DEFAULT_MODEL|CHAT_MODEL|CODE_MODEL|AI_TIMEOUT)
                    # Validate that value doesn't contain dangerous characters
                    if [[ "$value" =~ ^[a-zA-Z0-9_:./-]+$ ]]; then
                        export "$key=$value"
                    fi
                    ;;
            esac
        done < "$config_file"
    fi
}

# Check dependencies
check_dependencies() {
    local missing=()

    for cmd in aichat wofi wl-copy wl-paste notify-send jq; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Error: Missing dependencies: ${missing[*]}" >&2
        notify-send "Missing Dependencies" "Please install: ${missing[*]}" -u critical
        return 1
    fi

    return 0
}

# Check if aichat is accessible
check_aichat() {
    local test_output
    test_output=$(aichat --list-models 2>&1)
    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        log_error "Cannot connect to AI service. Error: $test_output" "check_aichat"

        # Check if it's an Ollama connection issue
        if [[ "$test_output" == *"ollama"* ]] || [[ "$test_output" == *"connection"* ]]; then
            notify-send "Ollama Connection Error" "Make sure Ollama is running:\nollama serve" -u critical
        fi

        return 1
    fi
    return 0
}

# Get available models with caching
get_models_cached() {
    # Refresh cache if older than 1 hour or doesn't exist
    if [[ ! -f "$MODELS_CACHE" ]] || [[ $(find "$MODELS_CACHE" -mmin +60 2>/dev/null) ]]; then
        local temp_file="$MODELS_CACHE.tmp"

        # Get models from aichat
        if ! aichat --list-models > "$temp_file" 2>&1; then
            local error_msg=$(cat "$temp_file")
            log_error "aichat --list-models failed: $error_msg" "get_models_cached"
            rm -f "$temp_file"
            return 1
        fi

        # Simply take each non-empty line as a model
        grep -v '^$' "$temp_file" > "$MODELS_CACHE"
        rm -f "$temp_file"

        # Check if we got any models
        if [[ ! -s "$MODELS_CACHE" ]]; then
            log_error "No models found in aichat output" "get_models_cached"
            return 1
        fi
    fi

    cat "$MODELS_CACHE"
}

# Get first available model as fallback
get_first_available_model() {
    get_models_cached | head -n1
}

# Validate model exists
validate_model() {
    local model="$1"
    get_models_cached | grep -q "^${model}$"
}

# Get model for specific mode
get_model_for_mode() {
    local mode="$1"
    case "$mode" in
        code) echo "${CODE_MODEL:-$DEFAULT_MODEL}" ;;
        chat) echo "${CHAT_MODEL:-$DEFAULT_MODEL}" ;;
        *) echo "$DEFAULT_MODEL" ;;
    esac
}

# Get roles with caching
get_roles_cached() {
    if [[ ! -f "$ROLES_CACHE" ]] || [[ $(find "$ROLES_CACHE" -mmin +60 2>/dev/null) ]]; then
        if aichat --list-roles 2>/dev/null > "$ROLES_CACHE.tmp"; then
            mv "$ROLES_CACHE.tmp" "$ROLES_CACHE"
        fi
    fi
    [[ -f "$ROLES_CACHE" ]] && cat "$ROLES_CACHE"
}

# Send request through aichat with timeout and error handling
ai_request() {
    local prompt="$1"
    local model="${2:-$DEFAULT_MODEL}"
    local role="${3:-}"
    local context="${4:-ai_request}"

    # Show which model is being used
    notify-send "AI Assistant" "Using model: $model\nProcessing..." -t 2000

    # Create temp files for output and errors
    local temp_out=$(mktemp /tmp/wofi-ai-$$-out.XXXXXX)
    local temp_err=$(mktemp /tmp/wofi-ai-$$-err.XXXXXX)

    # Build command
    local cmd="timeout $AI_TIMEOUT aichat --model \"$model\""
    [[ -n "$role" ]] && cmd="$cmd --role \"$role\""

    # Execute command with timeout
    if echo "$prompt" | eval "$cmd" > "$temp_out" 2> "$temp_err"; then
        local response=$(cat "$temp_out")

        # Check if response is empty
        if [[ -z "$response" ]]; then
            log_error "Empty response from model $model" "$context"
            rm -f "$temp_out" "$temp_err"
            return 1
        fi

        # Save to history
        save_to_history "$prompt" "$response" "$model"

        echo "$response"
        rm -f "$temp_out" "$temp_err"
        return 0
    else
        local exit_code=$?
        local error_output=$(cat "$temp_err")

        if [[ $exit_code -eq 124 ]]; then
            log_error "Request timed out after ${AI_TIMEOUT}s" "$context"
        else
            local error_msg="Exit code: $exit_code"
            [[ -n "$error_output" ]] && error_msg="$error_msg\nError: $error_output"
            log_error "$error_msg" "$context"
        fi

        rm -f "$temp_out" "$temp_err"
        return 1
    fi
}

# Get multiline input using editor
get_multiline_input() {
    local prompt_text="$1"
    local temp_file=$(mktemp /tmp/wofi-ai-$$-input.XXXXXX)

    # Pre-populate with template
    cat > "$temp_file" << EOF
# $prompt_text
# Lines starting with # will be ignored
# Save and exit when done

EOF

    # Open in preferred editor
    if command -v "$EDITOR" >/dev/null 2>&1; then
        $EDITOR "$temp_file"
    elif command -v nano >/dev/null 2>&1; then
        foot -e nano "$temp_file"
    else
        rm -f "$temp_file"
        return 1
    fi

    # Read content (skip comments and empty lines)
    local content=$(grep -v '^#' "$temp_file" | grep -v '^$' || true)
    rm -f "$temp_file"

    echo "$content"
}

# Confirm before sending clipboard content
confirm_clipboard_send() {
    local content="$1"
    local preview="${content:0:100}"
    [[ ${#content} -gt 100 ]] && preview="${preview}..."

    local confirm
    confirm=$(echo -e "Yes, send it\nNo, cancel" | \
        wofi --dmenu -p "Send clipboard to AI?" $WOFI_ARGS)

    [[ "$confirm" == "Yes, send it" ]]
}

# Handle response with follow-up options
handle_response() {
    local response="$1"
    local context="$2"

    # Show truncated response in notification (no automatic clipboard copy)
    local display_response="$response"
    if [[ ${#response} -gt 200 ]]; then
        display_response="${response:0:197}..."
    fi
    notify-send "AI Response" "$display_response" -t 10000

    # Offer follow-up actions
    local action
    action=$(echo -e "Copy to clipboard\nSave to file\nRefine this response\nAsk follow-up question\nDone" | \
        wofi --dmenu -p "What would you like to do?" $WOFI_ARGS)

    case "$action" in
        "Copy to clipboard")
            echo -n "$response" | wl-copy
            notify-send "Copied" "Response copied to clipboard" -t 3000
            ;;
        "Save to file")
            local filename
            filename=$(wofi --dmenu -p "Filename:" $WOFI_ARGS)
            if [[ -n "$filename" ]]; then
                # Add appropriate extension if not provided
                [[ "$filename" != *.* ]] && filename="${filename}.txt"
                echo "$response" > "$CACHE_DIR/$filename"
                notify-send "Saved" "Response saved to:\n$CACHE_DIR/$filename" -t 5000
            fi
            ;;
        "Refine this response")
            local refinement
            refinement=$(wofi --dmenu -p "How should I refine this?" $WOFI_ARGS)
            if [[ -n "$refinement" ]]; then
                local new_prompt="Refine this response: $refinement\n\nOriginal response: $response"
                mode_quick_query_with_prompt "$new_prompt"
            fi
            ;;
        "Ask follow-up question")
            local follow_up
            follow_up=$(wofi --dmenu -p "Follow-up question:" $WOFI_ARGS)
            if [[ -n "$follow_up" ]]; then
                local new_prompt="Context: $response\n\nFollow-up question: $follow_up"
                mode_quick_query_with_prompt "$new_prompt"
            fi
            ;;
        "Done"|"")
            # User selected Done or pressed Escape - do nothing
            return
            ;;
    esac
}

# Quick query mode
mode_quick_query() {
    local prompt
    prompt=$(wofi --dmenu -p "Ask AI" $WOFI_ARGS)
    [[ -z "$prompt" ]] && return

    mode_quick_query_with_prompt "$prompt"
}

mode_quick_query_with_prompt() {
    local prompt="$1"
    local response

    if response=$(ai_request "$prompt" "$DEFAULT_MODEL" "" "quick_query"); then
        handle_response "$response" "quick_query"
    fi
}

# Rewrite selection mode
mode_rewrite() {
    # Get clipboard content
    local content
    content=$(wl-paste 2>/dev/null)

    if [[ -z "$content" ]]; then
        notify-send "No Content" "Clipboard is empty. Copy some text first." -u normal
        return
    fi

    # Confirm before sending
    if ! confirm_clipboard_send "$content"; then
        return
    fi

    # Show rewrite options
    local action
    action=$(echo -e "Improve grammar and clarity\nMake more concise\nMake more formal\nMake more casual\nFix spelling and grammar\nTranslate to Spanish\nTranslate to French\nTranslate to German\nCustom instruction..." | \
        wofi --dmenu -p "Rewrite as" $WOFI_ARGS)

    [[ -z "$action" ]] && return

    local instruction
    if [[ "$action" == "Custom instruction..." ]]; then
        instruction=$(wofi --dmenu -p "Enter instruction" $WOFI_ARGS)
        [[ -z "$instruction" ]] && return
    else
        instruction="$action"
    fi

    local prompt="$instruction the following text, return only the rewritten text without explanation:\n\n$content"
    local response
    if response=$(ai_request "$prompt" "$DEFAULT_MODEL" "" "rewrite_text"); then
        handle_response "$response" "rewrite_text"
    fi
}

# Command generation mode
mode_command() {
    local request
    request=$(wofi --dmenu -p "What command do you need?" $WOFI_ARGS)
    [[ -z "$request" ]] && return

    # Use shell role if available
    local response
    local context="command_generation"

    if get_roles_cached | grep -q "shell"; then
        response=$(ai_request "$request" "$DEFAULT_MODEL" "shell" "$context")
    else
        local prompt="Generate 5 different shell commands for: $request. Output only the commands, one per line, no explanations, no markdown, no formatting."
        response=$(ai_request "$prompt" "$DEFAULT_MODEL" "" "$context")
    fi

    if [[ -n "$response" ]]; then
        # Clean up response
        response=$(echo "$response" | sed '/^```/d' | sed '/^$/d')

        # Let user select a command
        local selected_cmd
        selected_cmd=$(echo "$response" | wofi --dmenu -p "Select command" $WOFI_ARGS)

        if [[ -n "$selected_cmd" ]]; then
            handle_command "$selected_cmd"
        fi
    fi
}

# Handle selected command
handle_command() {
    local cmd="$1"

    local action
    action=$(echo -e "Execute\nCopy to clipboard\nEdit first" | wofi --dmenu -p "Action" $WOFI_ARGS)

    case "$action" in
        "Copy to clipboard")
            echo -n "$cmd" | wl-copy
            notify-send "Copied" "$cmd"
            ;;
        "Execute")
            notify-send "Executing" "$cmd"
            if ! eval "$cmd"; then
                log_error "Command execution failed: $cmd" "command_execute"
            fi
            ;;
        "Edit first")
            local edited_cmd
            edited_cmd=$(echo "$cmd" | wofi --dmenu -p "Edit command" $WOFI_ARGS)
            if [[ -n "$edited_cmd" ]]; then
                # Offer to copy or execute the edited command
                local edited_action
                edited_action=$(echo -e "Execute\nCopy to clipboard" | wofi --dmenu -p "Action for edited command" $WOFI_ARGS)
                case "$edited_action" in
                    "Execute")
                        notify-send "Executing" "$edited_cmd"
                        eval "$edited_cmd"
                        ;;
                    "Copy to clipboard")
                        echo -n "$edited_cmd" | wl-copy
                        notify-send "Copied" "$edited_cmd"
                        ;;
                esac
            fi
            ;;
    esac
}

# Code helper mode
mode_code() {
    # Get clipboard content or ask for input
    local code
    code=$(wl-paste 2>/dev/null)

    local action
    if [[ -n "$code" ]]; then
        action=$(echo -e "Explain this code\nFind bugs\nOptimize\nAdd comments\nConvert to different language\nWrite tests\nGenerate documentation\nUse new code...\nPaste multiline code..." | \
            wofi --dmenu -p "Code action" $WOFI_ARGS)
    else
        action="Use new code..."
    fi

    [[ -z "$action" ]] && return

    if [[ "$action" == "Use new code..." ]]; then
        code=$(wofi --dmenu -p "Paste your code" $WOFI_ARGS)
        [[ -z "$code" ]] && return
        action=$(echo -e "Explain this code\nFind bugs\nOptimize\nAdd comments\nConvert to different language\nWrite tests\nGenerate documentation" | \
            wofi --dmenu -p "Code action" $WOFI_ARGS)
        [[ -z "$action" ]] && return
    elif [[ "$action" == "Paste multiline code..." ]]; then
        code=$(get_multiline_input "Paste your code")
        [[ -z "$code" ]] && return
        action=$(echo -e "Explain this code\nFind bugs\nOptimize\nAdd comments\nConvert to different language\nWrite tests\nGenerate documentation" | \
            wofi --dmenu -p "Code action" $WOFI_ARGS)
        [[ -z "$action" ]] && return
    fi

    local prompt
    local context="code_helper_${action// /_}"
    local model=$(get_model_for_mode "code")

    case "$action" in
        "Explain this code")
            prompt="Explain what this code does in simple terms:\n\n$code"
            ;;
        "Find bugs")
            prompt="Find potential bugs or issues in this code:\n\n$code"
            ;;
        "Optimize")
            prompt="Optimize this code for better performance:\n\n$code"
            ;;
        "Add comments")
            prompt="Add helpful comments to this code:\n\n$code"
            ;;
        "Convert to different language")
            local target_lang
            target_lang=$(wofi --dmenu -p "Target language" $WOFI_ARGS)
            [[ -z "$target_lang" ]] && return
            prompt="Convert this code to $target_lang:\n\n$code"
            ;;
        "Write tests")
            prompt="Write comprehensive unit tests for this code:\n\n$code"
            ;;
        "Generate documentation")
            prompt="Generate detailed documentation for this code:\n\n$code"
            ;;
    esac

    local response
    if get_roles_cached | grep -q "code"; then
        response=$(ai_request "$prompt" "$model" "code" "$context")
    else
        response=$(ai_request "$prompt" "$model" "" "$context")
    fi

    if [[ -n "$response" ]]; then
        # For code responses, save to temp file and open in editor
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local temp_file="$CACHE_DIR/code_${action// /_}_${timestamp}.md"
        echo "$response" > "$temp_file"

        # Open in editor and offer clipboard option
        notify-send "Code Response" "Opening in editor: $temp_file" -t 3000

        # Try to open in preferred editor
        if command -v "${EDITOR:-}" >/dev/null 2>&1; then
            $EDITOR "$temp_file"
        elif command -v code >/dev/null 2>&1; then
            code "$temp_file"
        elif command -v vim >/dev/null 2>&1; then
            foot -e vim "$temp_file"
        fi

        # After editor, offer to copy
        local post_action
        post_action=$(echo -e "Copy to clipboard\nDone" | \
            wofi --dmenu -p "Would you like to copy the response?" $WOFI_ARGS)

        if [[ "$post_action" == "Copy to clipboard" ]]; then
            echo -n "$response" | wl-copy
            notify-send "Copied" "Code response copied to clipboard" -t 3000
        fi
    fi
}

# Start chat mode
mode_chat() {
    # Get available sessions
    local sessions
    sessions=$(aichat --list-sessions 2>&1) || sessions=""

    local session_action
    if [[ -n "$sessions" ]]; then
        session_action=$(echo -e "New session\n$sessions" | wofi --dmenu -p "Select session" $WOFI_ARGS)
    else
        session_action="New session"
    fi

    [[ -z "$session_action" ]] && return

    local model=$(get_model_for_mode "chat")
    local cmd="aichat --model $model"

    if [[ "$session_action" != "New session" ]]; then
        cmd="$cmd --session \"$session_action\""
    fi

    # Start chat in terminal
    if command -v foot >/dev/null 2>&1; then
        foot -e bash -c "$cmd || (echo 'aichat failed. Press enter to exit...'; read)"
    elif command -v alacritty >/dev/null 2>&1; then
        alacritty -e bash -c "$cmd || (echo 'aichat failed. Press enter to exit...'; read)"
    elif command -v kitty >/dev/null 2>&1; then
        kitty bash -c "$cmd || (echo 'aichat failed. Press enter to exit...'; read)"
    else
        log_error "No terminal emulator found" "mode_chat"
    fi
}

# Open Aider in terminal
mode_aider() {
    if command -v foot >/dev/null 2>&1; then
        foot -e bash -c "aider || (echo 'aider failed. Press enter to exit...'; read)"
    elif command -v alacritty >/dev/null 2>&1; then
        alacritty -e bash -c "aider || (echo 'aider failed. Press enter to exit...'; read)"
    elif command -v kitty >/dev/null 2>&1; then
        kitty bash -c "aider || (echo 'aider failed. Press enter to exit...'; read)"
    else
        log_error "No terminal emulator found" "mode_aider"
    fi
}

# Open Ollama in terminal
mode_ollama() {
    # Get available models
    local models
    models=$(ollama list 2>/dev/null | awk 'NR > 1 {print $1}' || true) || models=""

    if [[ -z "$models" ]]; then
        notify-send "Ollama Error" "No models available. Please install Ollama and its models first." -u critical
        return
    fi

    # Show model selection
    local selected_model
    selected_model=$(echo "$models" | wofi --dmenu -p "Select Ollama model" $WOFI_ARGS)
    [[ -z "$selected_model" ]] && return

    # Run selected model
    local cmd="ollama run \"$selected_model\""
    
    if command -v foot >/dev/null 2>&1; then
        foot -e bash -c "$cmd || (echo 'ollama failed. Press enter to exit...'; read)"
    elif command -v alacritty >/dev/null 2>&1; then
        alacritty -e bash -c "$cmd || (echo 'ollama failed. Press enter to exit...'; read)"
    elif command -v kitty >/dev/null 2>&1; then
        kitty bash -c "$cmd || (echo 'ollama failed. Press enter to exit...'; read)"
    else
        log_error "No terminal emulator found" "mode_ollama"
    fi
}

# Roles mode
mode_roles() {
    local roles
    roles=$(get_roles_cached)

    if [[ -z "$roles" ]]; then
        notify-send "No Roles" "No roles configured in aichat\nAdd roles to ~/.config/aichat/config.yaml" -u normal
        return
    fi

    local selected_role
    selected_role=$(echo "$roles" | wofi --dmenu -p "Select role" $WOFI_ARGS)
    [[ -z "$selected_role" ]] && return

    local prompt
    prompt=$(wofi --dmenu -p "Ask $selected_role" $WOFI_ARGS)
    [[ -z "$prompt" ]] && return

    local response
    if response=$(ai_request "$prompt" "$DEFAULT_MODEL" "$selected_role" "role_$selected_role"); then
        handle_response "$response" "role_$selected_role"
    fi
}

# History mode
mode_history() {
    if [[ ! -f "$HISTORY_FILE" ]] || [[ ! -s "$HISTORY_FILE" ]]; then
        notify-send "No History" "No previous conversations found" -u normal
        return
    fi

    # Show recent prompts
    local recent_prompts
    recent_prompts=$(tac "$HISTORY_FILE" | jq -r '"\(.timestamp | split("T")[0]) | \(.prompt | split("\n")[0])"' | head -20)

    local selected
    selected=$(echo "$recent_prompts" | wofi --dmenu -p "History" $WOFI_ARGS)
    [[ -z "$selected" ]] && return

    # Extract the prompt
    local prompt_line=$(echo "$selected" | cut -d'|' -f2- | sed 's/^ //')

    # Find full entry in history
    local full_entry
    full_entry=$(grep -F "$prompt_line" "$HISTORY_FILE" | tail -1)

    if [[ -n "$full_entry" ]]; then
        local response=$(echo "$full_entry" | jq -r '.response')

        # Offer options for historical response
        local action
        action=$(echo -e "Copy to clipboard\nSave to file\nDone" | \
            wofi --dmenu -p "What would you like to do with this response?" $WOFI_ARGS)

        case "$action" in
            "Copy to clipboard")
                echo -n "$response" | wl-copy
                notify-send "Copied" "Historical response copied to clipboard" -t 3000
                ;;
            "Save to file")
                local filename
                filename=$(wofi --dmenu -p "Filename:" $WOFI_ARGS)
                if [[ -n "$filename" ]]; then
                    [[ "$filename" != *.* ]] && filename="${filename}.txt"
                    echo "$response" > "$CACHE_DIR/$filename"
                    notify-send "Saved" "Response saved to:\n$CACHE_DIR/$filename" -t 5000
                fi
                ;;
        esac
    fi
}

# Settings mode
mode_settings() {
    local action
    action=$(echo -e "Select default model (current: $DEFAULT_MODEL)\nSelect code model (current: $CODE_MODEL)\nSelect chat model (current: $CHAT_MODEL)\nSet timeout (current: ${AI_TIMEOUT}s)\nManage aichat config\nView error log\nClear error log\nClear cache\nView settings file\nAbout" | \
        wofi --dmenu -p "Settings" $WOFI_ARGS)

    case "$action" in
        "Select default model"*)
            local model
            if model=$(get_models_cached | wofi --dmenu -p "Select model" $WOFI_ARGS); then
                if [[ -n "$model" ]]; then
                    echo "DEFAULT_MODEL=\"$model\"" > "$CONFIG_DIR/config"
                    DEFAULT_MODEL="$model"
                    notify-send "Settings" "Default model changed to $model\nRestart script to apply from settings file"
                fi
            fi
            ;;
        "Select code model"*)
            local model
            if model=$(get_models_cached | wofi --dmenu -p "Select code model" $WOFI_ARGS); then
                if [[ -n "$model" ]]; then
                    echo "CODE_MODEL=\"$model\"" >> "$CONFIG_DIR/config"
                    CODE_MODEL="$model"
                    notify-send "Settings" "Code model changed to $model\nRestart script to apply from settings file"
                fi
            fi
            ;;
        "Select chat model"*)
            local model
            if model=$(get_models_cached | wofi --dmenu -p "Select chat model" $WOFI_ARGS); then
                if [[ -n "$model" ]]; then
                    echo "CHAT_MODEL=\"$model\"" >> "$CONFIG_DIR/config"
                    CHAT_MODEL="$model"
                    notify-send "Settings" "Chat model changed to $model\nRestart script to apply from settings file"
                fi
            fi
            ;;
        "Set timeout"*)
            local timeout
            timeout=$(echo -e "10\n20\n30\n60\n120" | wofi --dmenu -p "Timeout (seconds)" $WOFI_ARGS)
            if [[ -n "$timeout" ]]; then
                echo "AI_TIMEOUT=\"$timeout\"" >> "$CONFIG_DIR/config"
                AI_TIMEOUT="$timeout"
                notify-send "Settings" "Timeout set to ${timeout}s\nRestart script to apply from settings file"
            fi
            ;;
        "Manage aichat config")
            notify-send "aichat config" "Run 'aichat --edit-config' in terminal\nOr edit: ~/.config/aichat/config.yaml"
            ;;
        "View error log")
            if [[ -f "$LOG_FILE" ]]; then
                tail -n 50 "$LOG_FILE" | wofi --dmenu -p "Error Log (last 50 lines)" $WOFI_ARGS -l 20
            else
                notify-send "No errors" "No error log found"
            fi
            ;;
        "Clear error log")
            > "$LOG_FILE"
            notify-send "Log cleared" "Error log has been cleared"
            ;;
        "Clear cache")
            rm -f "$MODELS_CACHE" "$ROLES_CACHE"
            cleanup_old_files
            notify-send "Cache cleared" "All cache files have been cleared"
            ;;
        "View settings file")
            local settings_locations="Checked in order:\n1. $SCRIPT_DIR/hacky-wofi-settings\n2. $CONFIG_DIR/hacky-wofi-settings\n3. ~/.hacky-wofi-settings\n\nCreate one of these files with:\nDEFAULT_MODEL=\"your-model\"\nCODE_MODEL=\"your-code-model\"\nCHAT_MODEL=\"your-chat-model\"\nAI_TIMEOUT=\"30\""
            notify-send "Settings File Locations" "$settings_locations" -t 10000
            ;;
        "About")
            local info="wofi-ai v$VERSION\n\nModels cache: $MODELS_CACHE\nRoles cache: $ROLES_CACHE\nHistory: $HISTORY_FILE\nError log: $LOG_FILE\n\nUsing: $(command -v aichat)\n\nSettings file locations checked:\n$SCRIPT_DIR/hacky-wofi-settings\n$CONFIG_DIR/hacky-wofi-settings\n~/.hacky-wofi-settings"
            echo -e "$info" | wofi --dmenu -p "About wofi-ai" $WOFI_ARGS -l 15
            ;;
    esac
}

# Initialize
init() {
    init_directories

    # Check dependencies on first run
    if ! check_dependencies; then
        exit 1
    fi

    # Load config
    load_config

    # Check AI backend
    if ! check_aichat; then
        exit 1
    fi

    # Validate and set fallback model
    if ! validate_model "$DEFAULT_MODEL"; then
        local fallback=$(get_first_available_model)
        if [[ -n "$fallback" ]]; then
            notify-send "Model Not Found" "Using fallback model: $fallback" -u warning
            DEFAULT_MODEL="$fallback"
        else
            log_error "No models available" "init"
            exit 1
        fi
    fi

    # Clean up old files periodically
    cleanup_old_files
}

# Main menu
main() {
    local menu="üí¨ Quick Query
‚úèÔ∏è  Rewrite Text
üñ•Ô∏è  Generate Command
üß© Code Helper
üé≠ Use Role
üí≠ Open AIChat
ü§ñ Open Aider
ü§° Open Ollama
üìú History
‚öôÔ∏è  Settings
‚ÑπÔ∏è  About (v$VERSION)"

    local selected
    selected=$(echo "$menu" | wofi --dmenu -p "AI Assistant" $WOFI_ARGS)

    case "$selected" in
        "üí¨ Quick Query") mode_quick_query ;;
        "‚úèÔ∏è  Rewrite Text") mode_rewrite ;;
        "üñ•Ô∏è  Generate Command") mode_command ;;
        "üß© Code Helper") mode_code ;;
        "üé≠ Use Role") mode_roles ;;
        "üí≠ Open AIChat") mode_chat ;;
        "ü§ñ Open Aider") mode_aider ;;
        "ü§° Open Ollama") mode_ollama ;;
        "üìú History") mode_history ;;
        "‚öôÔ∏è  Settings") mode_settings ;;
        "‚ÑπÔ∏è  About"*) mode_settings ;; # Reuse settings for about
    esac
}

# Handle direct mode access
case "${1:-}" in
    query) init && mode_quick_query ;;
    rewrite) init && mode_rewrite ;;
    command) init && mode_command ;;
    code) init && mode_code ;;
    roles) init && mode_roles ;;
    chat) init && mode_chat ;;
    history) init && mode_history ;;
    settings) init && mode_settings ;;
    log)
        if [[ -f "$LOG_FILE" ]]; then
            cat "$LOG_FILE"
        else
            echo "No error log found"
        fi
        ;;
    version)
        echo "wofi-ai version $VERSION"
        ;;
    *)
        init && main
        ;;
esac
